<!DOCTYPE HTML>
<html>
  <head>  
    <script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
	<script type="text/javascript" src="http://arc.id.au/Cango3D-7v09.js"></script>
        <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
      
</head>
<body>
 <canvas id="canvasID" width="0" height="0" style="border:1px solid black;"></canvas>
    
    <script type="text/javascript">

    // Set CANVAS width and height
    var cvsID = "canvasID";
    setCanvasDim();

    // Vars for world coordinates
    var coordsX = -($("#"+cvsID).attr("width")/2), // bottom leftmost pixel x
        coordsY = -($("#"+cvsID).attr("height")/2), // bottom leftmost pixel y
        coordsZ = -(2*coordsX);

    // Initialize Cango3D graphics context
    var g = new Cango3D(cvsID);
    g.setFOV(45);
    g.setPropertyDefault("backgroundColor", "lightyellow");
    g.setWorldCoords3D(coordsX, coordsY, coordsZ);
    
    // Generate Random Path Data
        var index = 0; // index for displacement array
        //var displacementframes = generateRandPath(); //generates displacement array with path data
        var rotationframes = [],
            displacementframes = [];
        var [rotationframes, displacementframes] = generatePutt(rotationframes,displacementframes);
    console.log(rotationframes);


        var convertedframes = applyZoffset(displacementframes); //apply z offset to displacement
    console.log("converted");
    //var createdPath = g.createGroup3D();
    
    // build the object
    var colors0 = ["#686868","#686868","#686868","#686868","#686868","#686868", "red"]; 
    var cube = buildPutter(g, 17*10, colors0);
    //var cube = buildCube(g, 10, ["red","orange","yellow","green","blue","violet"]);

    //var pathGraphic = buildPath();

    //var angleZ = 90;
    //g.setWorldCoords3D(coordsX, -coordsY, coordsZ);
    // Configure animation
    var timerinterval = 20;
    var timer = setInterval(movePutter, timerinterval);



// =============================================
  function setCanvasDim(){
        console.log("canvas DIM");
    width = 700;
    height = 700;
    $("#"+cvsID).attr("width", width);
    console.log($("#"+cvsID).attr("width"));
    $("#"+cvsID).attr("height", height);   

  }

  function generatePutt(rotations, displacement){
    var randIter = 1,
        displacement = [[0,0,0]],
        rotations = [[0,0,0]],
        scale = 1/2,
        xx = .1,
        yy = .1,
        zz = 3,
        xr = .66,
        yr = .3,
                duration = [ 0, 50,(scale)*50,(scale)*50  ],
    xPositionincrementer = [ -xx, (1/scale)*xx, -(1/scale)*xx, -xx],
    yPositionincrementer = [ yy, (1/scale)*(-yy), (1/scale)*(yy), yy],
    zPositionincrementer = [-zz, (1/scale)*zz, (1/scale)*zz, zz],
        
    xRotationincrementer = [ -xr, (1/scale)*xr,  (1/scale)*xr, xr], //hook
    yRotationincrementer = [ -yr, (1/scale)*yr, (1/scale)*yr, yr], //bent wrists before putt
    zRotationincrementer = [ 0, 0,  0, 0],
                                
    counter = 1,
    ii = 1;
    for (ii; ii < duration.length; ii=ii+1){
        console.log("ii");
        console.log(ii);
        ind = ii-1;
        for (randIter=counter; randIter < duration[ii]+counter; randIter = randIter+1 ){
            prevInd = randIter-1;
            xprev = displacement[prevInd][0];
            yprev = displacement[prevInd][1];
            zprev = displacement[prevInd][2];
            displacement.push([xprev-xPositionincrementer[ind],
                               yprev-yPositionincrementer[ind],
                               zprev-zPositionincrementer[ind]]);

            rotations.push([rotations[randIter-1][0] + xRotationincrementer[ind],
                            rotations[randIter-1][1] + yRotationincrementer[ind],
                            rotations[randIter-1][2] + zRotationincrementer[ind]]);
            //console.log("innerloop");
        }
        counter = counter + duration[ii]; // update total iteration count
        console.log("counter");
        console.log(counter);
    }
    
    return [rotations, displacement];
  }


  function movePutter() // move putter based on convertedframes
  {
    
    if (index == 0) { // first iteration

        // grab displacement values from array
        X = convertedframes[index][0];
        Y = convertedframes[index][1];
        Z = convertedframes[index][2];

        //console.log(rotationframes);
        console.log(rotationframes[index][0]);
        cube.transform.rotate(1,0,0,rotationframes[index][0]);  
        cube.transform.rotate(0,1,0,rotationframes[index][1]);  
        cube.transform.rotate(0,0,1,rotationframes[index][2]);
        g.setWorldCoords3D(coordsX+X, coordsY+Y, coordsZ+Z);
        g.renderFrame(cube);
        
    } else if (index > convertedframes.length - 1){ //when the displacement array ends
        // RESET
        index = -1;
        
        clearTimeout(timer);
        
        setTimeout(function() {
            cube.transform.reset();
            timer = setInterval(movePutter, timerinterval);
        }, 2000);
        

    } else {
        // grab displacement values from array
        X = convertedframes[index][0];
        Y = convertedframes[index][1];
        Z = convertedframes[index][2];
        
        
        //console.log(rotationframes);
        //console.log(rotationframes[index][0]);
        cube.transform.rotate(1,0,0,rotationframes[index][0]-rotationframes[index-1][0]);  
        cube.transform.rotate(0,1,0,rotationframes[index][1]-rotationframes[index-1][1]);  
        cube.transform.rotate(0,0,1,rotationframes[index][2]-rotationframes[index-1][2]);
        g.setWorldCoords3D(coordsX+X, coordsY+Y, coordsZ+Z);
        
    }
    

    index = index + 1; // advance to next array index
        
    g.renderFrame(cube);
    
  }




  function applyZoffset(displacementframes){ 
    // applies the z offset to a frame from the sensor
    //   -> returns the new displacement frames
    // desired displacement (in terms of x,y,z pixel positions)

    console.log("applyZoffset");
    newframes = [[0,0,0]];

    //Check screen size
    pageWidth = $("#"+cvsID).attr("width")-2; //subtraction eliminates border pixels (also str to int)
    pageHeight = $("#"+cvsID).attr("height")-2;
    if (pageWidth > pageHeight ){
        z1 = .5;
        z2 = pageHeight/(2*pageWidth);
    } else {
        z1 = pageWidth/(pageWidth+pageHeight);
        z2 = pageHeight/(pageWidth+pageHeight);
    }

    z3 = -1;
    Zoffset = [z1,z2,z3]; 
    
    // iterate through old frames
    var j = 1;  
    for (j = 1; j< displacementframes.length - 1; j++){
        
        // Calculate position increment from displacement data
        xdisp = displacementframes[j][0] - displacementframes[j-1][0];
        ydisp = displacementframes[j][1] - displacementframes[j-1][1];
        zdisp = displacementframes[j][2] - displacementframes[j-1][2];
        
        // take into account z bias and position increments
        xincrementer = xdisp + Zoffset[0]*(zdisp);
        yincrementer = ydisp + Zoffset[1]*(zdisp);
        zincrementer = Zoffset[2]*(zdisp);
    
        // update displacement frames based on z bias
        newframesX = newframes[j-1][0] + xincrementer;
        newframesY = newframes[j-1][1] + yincrementer;
        newframesZ = newframes[j-1][2] + zincrementer;
        
        // append new array
        newframes.push([newframesX,newframesY,newframesZ]);    
    }
      
    return newframes;
  }







  function generateRandPath(){
    var randIter = 1,
        displacement = [[0,0,0]],
        xPositionincrementer = 2,
        yPositionincrementer = 0,
        zPositionincrementer = 4;
      
    for (randIter; randIter < 100; randIter = randIter + 1 ){
        xprev = displacement[randIter-1][0];
        yprev = displacement[randIter-1][1];
        zprev = displacement[randIter-1][2];
        displacement.push([xprev-xPositionincrementer,yprev-yPositionincrementer,zprev-zPositionincrementer]);
    }
    return displacement;
  }



  function buildPutter(g, height, colors){
        
    shaft2ShaftPlusGripRatio = 7/10;// height input in pixels scaled to the canvas height
    // Customize your putter
    buttDisplacementScalar = 6; // essentially the x displacement from tip of the shaft to the putter head
    putterHeightScalar = 17;
    width = height/putterHeightScalar;
    
    var sq = [['M',0,0,0, 'L',width*4,0,0, width*4,width,0, 0,width,0, 'z']];
      sq.push(sq[0]);
      sq.push(sq[0]);
      sq.push(sq[0]);
      sq.push(['M',0,0,0, 'L',width,0,0, width,width,0, 0,width,0, 'z']);
      sq.push(sq[4]);
      sq.push(['M',0,0,0, 'L',width/2,0,0, width/2,width/2,0, 0,width/2,0, 'z']); // dot on putter head
    
      var faces = g.createGroup3D(),
      side,
      translateX = [-width*2,-width*2,-width*2,-width*2,-width/2,-width/2,-width/4],
      translateY = [0,-width/2,-width/2, -width,0,0,width/4],
      translateZ = [width/2,0,width,width/2,width*2,width*2,width/2+1],
      rotateX = [1,1,1,1,0,0,0],
      rotateY = [1,0,0,0,1,1,1],
      rotateZ = [1,0,0,0,0,0,0],
      rotateMag = [0,90,-90,180,90,-90,180],
      i;

    for (i=0; i<7; i++){
        //console.log(i)
        side = g.compileShape3D(sq[i], colors[i]);
        side.translate(translateX[i], translateY[i], translateZ[i]);
        side.rotate(rotateX[i], rotateY[i], rotateZ[i], rotateMag[i]);
        side.backHidden = true;
        faces.addObj(side);
    }
    
    shaft2ShaftPlusGripRatio = 7/10;
    // creating the shaft
    lowerShaft = g.compilePath3D(["M",-width,width,0, "L",-width,2*width,0], "#686868", width/3);
    faces.addObj(lowerShaft);
      
    upperShaft = g.compilePath3D(["M",-width,2*width,0, "L",(shaft2ShaftPlusGripRatio)*(-buttDisplacementScalar*width),(shaft2ShaftPlusGripRatio)*(putterHeightScalar*width),0], "#A8A8A8", width/4);
    faces.addObj(upperShaft);
      
    grip = g.compilePath3D(["M",(shaft2ShaftPlusGripRatio)*(-buttDisplacementScalar*width),(shaft2ShaftPlusGripRatio)*(putterHeightScalar*width),0, "L",(-buttDisplacementScalar*width),(putterHeightScalar*width),0], "#202020", width/3);
    faces.addObj(grip);
      
    // reference putter head to the center
    faces.translate(0,-width/2,0);
      
    // add axes for visual debugging
    centerX = g.compilePath3D(["M",-4*width,0,0, "L",4*width,0,0], "green", 1);
    faces.addObj(centerX);
    centerY = g.compilePath3D(["M",0,-4*width,0, "L",0,4*width,0], "green", 1);
    faces.addObj(centerY);
    centerZ = g.compilePath3D(["M",0,0,-4*width, "L",0,0,4*width], "green", 1);
    faces.addObj(centerZ);
      
    
    
    
    return faces;
  }

function buildCube(g, width, colors){ // pass width and array of 6 colors
  var sq = ['M',0,0,0, 'L',width,0,0, width,width,0, 0,width,0, 'z'],
      faces = g.createGroup3D(),
      side,
      translateX = [-width/2,-width/2,-width/2,-width/2,-width/2,-width/2],
      translateY = [-width/2,-width/2,-width/2, -width/2,-width/2,-width/2],
      translateZ = [width/2,width/2,width/2,width/2,width/2,width/2],
      rotateX = [1,1,1,1,0,0],
      rotateY = [1,0,0,0,1,1],
      rotateZ = [1,0,0,0,0,0],
      rotateMag = [0,90,-90,180,90,-90],
      i;

  for (i=0; i<6; i++)
  {
    console.log(i)
    side = g.compileShape3D(sq, colors[i]);
    side.translate(translateX[i], translateY[i], translateZ[i]);
    side.rotate(rotateX[i], rotateY[i], rotateZ[i], rotateMag[i]);
    side.backHidden = true;
    faces.addObj(side);
  }
    // Axes added for visual debugging
    centerX = g.compilePath3D(["M",-50,0,0, "L",50,0,0], "black", 1);
    faces.addObj(centerX);
    centerY = g.compilePath3D(["M",0,-50,0, "L",0,50,0], "black", 1);
    faces.addObj(centerY);
    centerZ = g.compilePath3D(["M",0,0,-50, "L",0,0,50], "black", 1);
    faces.addObj(centerZ);
        
  return faces;
}

  </script>
    
  </body>
</html>  
