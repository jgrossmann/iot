<!DOCTYPE HTML>
<html>
  <head>  
    <script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
	<script type="text/javascript" src="http://arc.id.au/Cango3D-7v09.js"></script>
        <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
      
</head>
<body>
 <canvas id="canvasID" width="0" height="0" style="border:1px solid black;"></canvas>
    
    <script type="text/javascript">

    // Set CANVAS width and height
    var cvsID = "canvasID";
    setCanvasDim();

    // Vars for world coordinates
    var coordsX = -($("#"+cvsID).attr("width")/2), // bottom leftmost pixel x
        coordsY = -($("#"+cvsID).attr("height")/2), // bottom leftmost pixel y
        coordsZ = -(2*coordsX);
    
    // Initialize Cango3D graphics context
    var g = new Cango3D(cvsID);
    g.setFOV(45);
    g.setPropertyDefault("backgroundColor", "lightyellow");
    g.setWorldCoords3D(coordsX, coordsY, coordsZ);
    
    // Generate Random Path Data
        var index = 0; // index for displacement array
        var displacementframes = generateRandPath(); //generates displacement array with path data
        var convertedframes = applyZoffset(displacementframes); //apply z offset to displacement
    
    var createdPath = g.createGroup3D();
    
    // build the object
    var cube = buildPutter(g, 17*10, ["#686868","#686868","#686868","#686868","#686868","#686868", "red"]);
    //var cube = buildCube(g, 10, ["red","orange","yellow","green","blue","violet"]);

    //var pathGraphic = buildPath();

    //var angleZ = 90;
    //g.setWorldCoords3D(coordsX, -coordsY, coordsZ);
    // Configure animation
    var timerinterval = 10;
    var timer = setInterval(movePutter, timerinterval);



// =============================================
  function setCanvasDim(){
    width = 700;
    height = 700;
    $("#"+cvsID).attr("width", width);
    //console.log($("#"+cvsID).attr("width"));
    $("#"+cvsID).attr("height", height);   
  }

  function movePutter() // move putter based on convertedframes
  {
    
    if (index > convertedframes.length - 1){ //when the displacement array ends
        X = convertedframes[index-2][0];
        Y = convertedframes[index-2][1];
        Z = convertedframes[index-2][2];
        console.log("here");
        
        // RESET
        index = -1;
        //g.deleteObj(cube);
        // Create path
        console.log("here");
        dot = g.compilePath3D(["M",0,0,0,
                               "L",X,Y,Z], "red", 4);
        createdPath.addObj(dot);

        g.renderFrame(createdPath);
        console.log("here");
        g.deleteObj(cube);
        /*
        cube = buildPutter(g, 17*10, ["#686868","#686868","#686868","#686868","#686868","#686868", "red"]);
        cube.transform.reset();
        */
    } else {

        // grab displacement values from array
        X = convertedframes[index][0];
        Y = convertedframes[index][1];
        Z = convertedframes[index][2];

        //cube.transform.rotate(1,1,0,1);  
        g.setWorldCoords3D(coordsX+X, coordsY+Y, coordsZ+Z);
        
    }
        
    g.renderFrame(cube);
    //g.renderFrame(pathGraphic);
      
    index = index + 1; // advance to next array index
  }




  function applyZoffset(displacementframes){ 
    // applies the z offset to a frame from the sensor
    //   -> returns the new displacement frames
    // desired displacement (in terms of x,y,z pixel positions)

    console.log("applyZoffset");
    newframes = [[0,0,0]];

    //Check screen size
    pageWidth = $("#"+cvsID).attr("width")-2; //subtraction eliminates border pixels (also str to int)
    pageHeight = $("#"+cvsID).attr("height")-2;
    if (pageWidth > pageHeight ){
        z1 = .5;
        z2 = pageHeight/(2*pageWidth);
    } else {
        z1 = pageWidth/(pageWidth+pageHeight);
        z2 = pageHeight/(pageWidth+pageHeight);
    }

    z3 = -1;
    Zoffset = [z1,z2,z3]; 
    
    // iterate through old frames
    var j = 1;  
    for (j = 1; j< displacementframes.length - 1; j++){
        
        // Calculate position increment from displacement data
        xdisp = displacementframes[j][0] - displacementframes[j-1][0];
        ydisp = displacementframes[j][1] - displacementframes[j-1][1];
        zdisp = displacementframes[j][2] - displacementframes[j-1][2];
        
        // take into account z bias and position increments
        xincrementer = xdisp + Zoffset[0]*(zdisp);
        yincrementer = ydisp + Zoffset[1]*(zdisp);
        zincrementer = Zoffset[2]*(zdisp);
    
        // update displacement frames based on z bias
        newframesX = newframes[j-1][0] + xincrementer;
        newframesY = newframes[j-1][1] + yincrementer;
        newframesZ = newframes[j-1][2] + zincrementer;
        
        // append new array
        newframes.push([newframesX,newframesY,newframesZ]);    
    }
      
    return newframes;
  }




  function generateRandPath(){
    var randIter = 1,
        displacement = [[0,0,0]],
        xPositionincrementer = 2,
        yPositionincrementer = 0,
        zPositionincrementer = 4;
      
    for (randIter; randIter < 100; randIter = randIter + 1 ){
        xprev = displacement[randIter-1][0];
        yprev = displacement[randIter-1][1];
        zprev = displacement[randIter-1][2];
        displacement.push([xprev-xPositionincrementer,yprev-yPositionincrementer,zprev-zPositionincrementer]);
    }/*
        xPositionincrementer = 0,
        yPositionincrementer = -1,
        zPositionincrementer = 0;
    for (randIter; randIter < 200; randIter = randIter + 1 ){
        xprev = displacement[randIter-1][0];
        yprev = displacement[randIter-1][1];
        zprev = displacement[randIter-1][2];
        displacement.push([xprev-xPositionincrementer,yprev-yPositionincrementer,zprev-zPositionincrementer]);
    }
        xPositionincrementer = -1,
        yPositionincrementer = 0,
        zPositionincrementer = -4;
    for (randIter; randIter < 300; randIter = randIter + 1 ){
        xprev = displacement[randIter-1][0];
        yprev = displacement[randIter-1][1];
        zprev = displacement[randIter-1][2];
        displacement.push([xprev-xPositionincrementer,yprev-yPositionincrementer,zprev-zPositionincrementer]);
    }
        xPositionincrementer = 0,
        yPositionincrementer = 0,
        zPositionincrementer = -4;
    for (randIter; randIter < 400; randIter = randIter + 1 ){
        xprev = displacement[randIter-1][0];
        yprev = displacement[randIter-1][1];
        zprev = displacement[randIter-1][2];
        displacement.push([xprev-xPositionincrementer,yprev-yPositionincrementer,zprev-zPositionincrementer]);
    }*/
    return displacement;
  }



  function buildPutter(g, height, colors){
        
    shaft2ShaftPlusGripRatio = 7/10;// height input in pixels scaled to the canvas height
    // Customize your putter
    buttDisplacementScalar = 6; // essentially the x displacement from tip of the shaft to the putter head
    putterHeightScalar = 17;
    width = height/putterHeightScalar;
    
    var sq = [['M',0,0,0, 'L',width*4,0,0, width*4,width,0, 0,width,0, 'z']];
      sq.push(sq[0]);
      sq.push(sq[0]);
      sq.push(sq[0]);
      sq.push(['M',0,0,0, 'L',width,0,0, width,width,0, 0,width,0, 'z']);
      sq.push(sq[4]);
      sq.push(['M',0,0,0, 'L',width/2,0,0, width/2,width/2,0, 0,width/2,0, 'z']); // dot on putter head
    
      var faces = g.createGroup3D(),
      side,
      translateX = [-width*2,-width*2,-width*2,-width*2,-width/2,-width/2,-width/4],
      translateY = [0,-width/2,-width/2, -width,0,0,width/4],
      translateZ = [width/2,0,width,width/2,width*2,width*2,width/2+1],
      rotateX = [1,1,1,1,0,0,0],
      rotateY = [1,0,0,0,1,1,1],
      rotateZ = [1,0,0,0,0,0,0],
      rotateMag = [0,90,-90,180,90,-90,180],
      i;

    for (i=0; i<7; i++){
        //console.log(i)
        side = g.compileShape3D(sq[i], colors[i]);
        side.translate(translateX[i], translateY[i], translateZ[i]);
        side.rotate(rotateX[i], rotateY[i], rotateZ[i], rotateMag[i]);
        side.backHidden = true;
        faces.addObj(side);
    }
    
    shaft2ShaftPlusGripRatio = 7/10;
    // creating the shaft
    lowerShaft = g.compilePath3D(["M",-width,width,0, "L",-width,2*width,0], "#686868", width/3);
    faces.addObj(lowerShaft);
      
    upperShaft = g.compilePath3D(["M",-width,2*width,0, "L",(shaft2ShaftPlusGripRatio)*(-buttDisplacementScalar*width),(shaft2ShaftPlusGripRatio)*(putterHeightScalar*width),0], "#A8A8A8", width/4);
    faces.addObj(upperShaft);
      
    grip = g.compilePath3D(["M",(shaft2ShaftPlusGripRatio)*(-buttDisplacementScalar*width),(shaft2ShaftPlusGripRatio)*(putterHeightScalar*width),0, "L",(-buttDisplacementScalar*width),(putterHeightScalar*width),0], "#202020", width/3);
    faces.addObj(grip);
      
    // reference putter head to the center
    faces.translate(0,-width/2,0);
      
    // add axes for visual debugging
    centerX = g.compilePath3D(["M",-4*width,0,0, "L",4*width,0,0], "green", 1);
    faces.addObj(centerX);
    centerY = g.compilePath3D(["M",0,-4*width,0, "L",0,4*width,0], "green", 1);
    faces.addObj(centerY);
    centerZ = g.compilePath3D(["M",0,0,-4*width, "L",0,0,4*width], "green", 1);
    faces.addObj(centerZ);
      
    
    
    
    return faces;
  }

function buildCube(g, width, colors){ // pass width and array of 6 colors
  var sq = ['M',0,0,0, 'L',width,0,0, width,width,0, 0,width,0, 'z'],
      faces = g.createGroup3D(),
      side,
      translateX = [-width/2,-width/2,-width/2,-width/2,-width/2,-width/2],
      translateY = [-width/2,-width/2,-width/2, -width/2,-width/2,-width/2],
      translateZ = [width/2,width/2,width/2,width/2,width/2,width/2],
      rotateX = [1,1,1,1,0,0],
      rotateY = [1,0,0,0,1,1],
      rotateZ = [1,0,0,0,0,0],
      rotateMag = [0,90,-90,180,90,-90],
      i;

  for (i=0; i<6; i++)
  {
    console.log(i)
    side = g.compileShape3D(sq, colors[i]);
    side.translate(translateX[i], translateY[i], translateZ[i]);
    side.rotate(rotateX[i], rotateY[i], rotateZ[i], rotateMag[i]);
    side.backHidden = true;
    faces.addObj(side);
  }
    // Axes added for visual debugging
    centerX = g.compilePath3D(["M",-50,0,0, "L",50,0,0], "black", 1);
    faces.addObj(centerX);
    centerY = g.compilePath3D(["M",0,-50,0, "L",0,50,0], "black", 1);
    faces.addObj(centerY);
    centerZ = g.compilePath3D(["M",0,0,-50, "L",0,0,50], "black", 1);
    faces.addObj(centerZ);
        
  return faces;
}

  </script>
    
  </body>
</html>  
